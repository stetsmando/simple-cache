/*!
 * 
 * @license SimpleCache v2.X
 * 
 * Author: Stetson Pierce
 * 
 * This source code is licensed under the MIT license.
 */
var SimpleCache=function(e){var t={};function o(r){if(t[r])return t[r].exports;var s=t[r]={i:r,l:!1,exports:{}};return e[r].call(s.exports,s,s.exports,o),s.l=!0,s.exports}return o.m=e,o.c=t,o.d=function(e,t,r){o.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},o.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(e,t){if(1&t&&(e=o(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(o.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var s in e)o.d(r,s,function(t){return e[t]}.bind(null,s));return r},o.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return o.d(t,"a",t),t},o.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},o.p="",o(o.s=0)}([function(e,t,o){"use strict";o.r(t);class r{constructor(e){this.isActive=e||!1,this.key="SC:"}log(e){this.isActive&&console.log(`${this.key} ${e}`)}}o.d(t,"default",function(){return i});const s=new class{set(e,t){localStorage.setItem(e,JSON.stringify(t))}get(e){return localStorage.getItem(e)}remove(e){localStorage.removeItem(e)}},l=new class{set(e,t){sessionStorage.setItem(e,JSON.stringify(t))}get(e){return sessionStorage.getItem(e)}remove(e){sessionStorage.removeItem(e)}};class i{constructor(e={}){this.ttl=e.ttl||864e5,this.namespace=e.namespace||"SC_",this.logger=new r(e.logMessages||!1)}async set(...e){if("string"==typeof e[0]){const t=`${this.namespace}${e[0]}`;if(this.logger.log("Set Single"),this.logger.log(`Key ${t}`),e[2]){const o=this.buildItem(e[1]);this.logger.log("Storing in Session"),this.logger.log(`Item ${JSON.stringify(o)}`),l.set(t,o)}else{const o=this.buildItem(e[1]);this.logger.log("Storing in Local"),this.logger.log(`Item ${JSON.stringify(o)}`),s.set(t,o)}}else if(Array.isArray(e[0])){if(this.logger.log("Set Multi"),e[1]){this.logger.log("Storing in Session"),this.logger.log(`Values ${e[0]}`);const t=[];return e[0].forEach(e=>{t.push(new Promise((t,o)=>{const r=`${this.namespace}${e.key}`,s=this.buildItem(e);this.logger.log(`Item ${JSON.stringify(s)}`),l.set(r,s),t()}))}),this.logger.log("All Promises Created"),Promise.all(t)}{this.logger.log("Storing in Local"),this.logger.log(`Values ${e[0]}`);const t=[];return e[0].forEach(e=>{t.push(new Promise((t,o)=>{const r=`${this.namespace}${e.key}`,l=this.buildItem(e);this.logger.log(`Item ${JSON.stringify(l)}`),s.set(r,l),t()}))}),this.logger.log("All Promises Created"),Promise.all(t)}}}async get(...e){if("string"==typeof e[0]){const t=`${this.namespace}${e[0]}`;let o="session";this.logger.log("Get Single"),this.logger.log(`Key ${t}`),this.logger.log("Checking Session...");let r=l.get(t);if(!(r||(this.logger.log("Checking Local..."),this.found="local",r=s.get(t))))return this.logger.log("Nothing Found"),null;if(this.logger.log("Item Found"),r=JSON.parse(r),Date.now()>=r.ttl){if(this.logger.log("Item Expired"),"session"!==o)return this.logger.log("Item Expired"),this.logger.log("Remove Local"),s.remove(t),null;if(this.logger.log("Remove Session"),l.remove(t),this.logger.log("Checking Local..."),!(r=s.get(t)))return this.logger.log("Local Not Found"),null;if(this.logger.log("Item Found"),r=JSON.parse(r),Date.now()>=r.ttl)return this.logger.log("Item Expired"),this.logger.log("Remove Local"),s.remove(t),null}return r.value}if(Array.isArray(e[0])){const t=[];return e[0].forEach(e=>{t.push(new Promise((t,o)=>{let r=s.get(`${this.namespace}${e}`);return r?(r=JSON.parse(r),Date.now()>=r.ttl?(s.remove(`${this.namespace}${e}`),t(null)):t(r.value)):t(null)}))}),await Promise.all(t)}}async remove(...e){if("string"==typeof e[0]){this.logger.log("Remove Single");const t=`${this.namespace}${e[0]}`;this.logger.log(`Key ${t}`),s.remove(t),l.remove(t)}else if(Array.isArray(e[0])){this.logger.log("Remove Multi");const t=[];return e[0].forEach(e=>{t.push(new Promise((t,o)=>{const r=`${this.namespace}${e}`;this.logger.log(`Key ${r}`),s.remove(r),l.remove(r),t()}))}),await Promise.all(t)}}buildItem(e){let t=this.ttl;return e.ttl&&(t=e.ttl,delete e.ttl),{value:e,ttl:t+=Date.now()}}}}]);